{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Not Nick dummy notes","text":""},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#compute","title":"Compute","text":"<ul> <li>EC2 - Elastic Compute Cloud</li> <li>Lambda - Serverless Functions</li> <li>Elastic Beanstalk - PaaS Solution</li> </ul>"},{"location":"#storage","title":"Storage","text":"<ul> <li>S3 - Simple Storage Service</li> </ul>"},{"location":"#security","title":"Security","text":"<ul> <li>IAM - Identity and Access Management</li> <li>Cognito - User Authentication and Authorization</li> </ul>"},{"location":"#networking","title":"Networking","text":"<ul> <li>API Gateway - API Management</li> <li>CloudFront - Content Delivery Network</li> <li>Route 53 - DNS Service</li> </ul>"},{"location":"#database","title":"Database","text":"<ul> <li>DynamoDB - NoSQL Database</li> </ul>"},{"location":"#messaging","title":"Messaging","text":"<ul> <li>SQS - Simple Queue Service</li> <li>Kinesis - Real-time Data Streaming</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>Step Functions - Workflow Orchestration</li> </ul>"},{"location":"compute/ec2/","title":"Types","text":"<ol> <li> <p>Dedicated Hosts</p> </li> <li> <p>Physical servers with EC2 instance capacity fully dedicated to your use.</p> </li> <li>Own license and compliance benefits.</li> <li> <p>more expensive than Dedicated Instances</p> </li> <li> <p>Dedicated Instances</p> </li> <li>Run in a VPC on hardware that's dedicated to a single customer.</li> <li>May share hardware with other instances from the same AWS account.</li> </ol>"},{"location":"compute/ec2/#aws-account-free","title":"AWS account free","text":"<ul> <li>Account less than 12 months old can use t2.micro or t3.micro free for 750 hours per month</li> <li>After 12 months, you will be charged the standard, pay-as-you-go service rates</li> </ul>"},{"location":"compute/elastic-beanstalk/","title":"Elastic Beanstalk Deployment Policies Comparison","text":"Feature All at Once Rolling Rolling with Additional Batch Immutable Blue/Green Deploy Time Fastest \u26a1\ufe0f Moderate \ud83d\udd52 Slow \ud83d\udd52 Slower \ud83d\udd52 Slowest \u23f0 Zero Downtime? \u274c Has downtime \u2705 Minimal impact \u2705 No downtime \u2705 No downtime \u2705 No downtime Impact of Failed Deployment High Risk \u26a0\ufe0fAll instances affected Medium Risk \ud83d\udd36Only subset affected Low Risk \u2705Only subset affected Very Low Risk \u2705No impact on existing Very Low Risk \u2705Easy rollback Rollback Process Manual redeploySlow &amp; complex Manual redeployRolling back Manual redeployRolling back Quick \u26a1\ufe0fTerminate new instances Instant \u26a1\ufe0fSwitch to old version Code Deployed to Existing instances Existing instancesin batches Existing + new instancesin batches New instances only New environment DNS Change No No No No Yes"},{"location":"compute/elastic-beanstalk/#key-characteristics","title":"Key Characteristics","text":""},{"location":"compute/elastic-beanstalk/#all-at-once","title":"All at Once","text":"<ul> <li>Deploys to all instances simultaneously</li> <li>Fastest but highest risk</li> <li>Best for dev/test environments</li> <li>Has downtime during deployment</li> </ul>"},{"location":"compute/elastic-beanstalk/#rolling","title":"Rolling","text":"<ul> <li>Updates instances in batches</li> <li>Reduced capacity during deployment</li> <li>Some instances serve old version while others new</li> <li>Good for production with acceptable partial degradation</li> </ul>"},{"location":"compute/elastic-beanstalk/#rolling-with-additional-batch","title":"Rolling with Additional Batch","text":"<ul> <li>Like rolling but launches new instances first</li> <li>Maintains full capacity</li> <li>Takes longer but safer</li> <li>Good for production requiring full capacity</li> </ul>"},{"location":"compute/elastic-beanstalk/#immutable","title":"Immutable","text":"<ul> <li>Launches new instances with new version</li> <li>Zero downtime and quick rollback</li> <li>More expensive (double capacity temporarily)</li> <li>Safest for production</li> </ul>"},{"location":"compute/elastic-beanstalk/#bluegreen","title":"Blue/Green","text":"<ul> <li>Creates entirely new environment</li> <li>Zero downtime and instant rollback</li> <li>Most expensive (double capacity until swap)</li> <li>Best for critical production applications</li> <li>Requires DNS change (Route 53)</li> </ul>"},{"location":"compute/elastic-beanstalk/#best-practices","title":"Best Practices","text":"<ul> <li>Dev/Test: Use All at Once for speed</li> <li>Production (cost-sensitive): Use Rolling with Additional Batch</li> <li>Production (critical): Use Immutable or Blue/Green</li> <li>Always test deployment policy in dev/test environment first</li> </ul>"},{"location":"compute/lambda/","title":"Lambda Configuration and Scaling","text":""},{"location":"compute/lambda/#cpu-settings","title":"CPU Settings","text":"<ul> <li>Lambda does not allow you to set CPU directly</li> <li>CPU is allocated based on the amount of memory configured</li> </ul>"},{"location":"compute/lambda/#types-of-concurrency","title":"Types of Concurrency","text":"Feature Reserved Concurrency Provisioned Concurrency Purpose Limits maximum concurrency Pre-initializes function instances Use Case Limiting resource usage Reducing latency for predictable workloads Scaling Acts as a ceiling Can be auto-scaled Application Entire function (all versions) Specific versions or aliases Cost No additional cost Pay for provisioned instances"},{"location":"compute/lambda/#key-points-to-remember","title":"Key Points to Remember","text":"<ul> <li> <p>Reserved Concurrency:</p> </li> <li> <p>Acts as a hard limit on function concurrency</p> </li> <li>Guarantees maximum number of concurrent executions</li> <li>Cannot be managed by Application Auto Scaling</li> <li> <p>Useful for limiting costs or backend resources</p> </li> <li> <p>Provisioned Concurrency:</p> </li> <li>Pre-initializes function instances</li> <li>Eliminates cold starts</li> <li>Can be managed by Application Auto Scaling</li> <li>Perfect for predictable workload patterns</li> <li>Can be scheduled (e.g., for sales events)</li> </ul>"},{"location":"compute/lambda/#scaling-patterns","title":"Scaling Patterns","text":"<ol> <li> <p>Default Scaling:</p> </li> <li> <p>Functions scale automatically</p> </li> <li>May experience cold starts</li> <li> <p>No additional cost</p> </li> <li> <p>Reserved Concurrency Pattern:</p> </li> </ol> <pre><code>Function \u2500\u25ba Reserved Concurrency (100)\n             \u2514\u2500\u25ba Cannot exceed 100 concurrent executions\n</code></pre> <ol> <li>Provisioned Concurrency Pattern:    <pre><code>Function \u2500\u25ba Provisioned Concurrency (50)\n             \u2514\u2500\u25ba Auto Scaling (based on schedule/utilization)\n                 \u2514\u2500\u25ba Can scale up/down within limits\n</code></pre></li> </ol>"},{"location":"compute/lambda/#real-world-example-black-friday-sale","title":"Real-World Example (Black Friday Sale)","text":"<pre><code>Before Sale Hours:\n\u2514\u2500\u25ba Provisioned Concurrency: 10 instances\n\nDuring Sale (Auto Scaled):\n\u2514\u2500\u25ba Provisioned Concurrency: Scales to 100 instances\n    \u2514\u2500\u25ba All requests handled by warm instances\n    \u2514\u2500\u25ba No cold starts = Consistent low latency\n</code></pre>"},{"location":"compute/lambda/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Provisioned Concurrency when:</p> </li> <li> <p>You have predictable traffic patterns</p> </li> <li>Cold starts are unacceptable</li> <li> <p>You can schedule scaling events</p> </li> <li> <p>Use Reserved Concurrency when:</p> </li> <li> <p>You need to limit resource usage</p> </li> <li>You need to guarantee capacity for specific functions</li> <li> <p>You want to prevent one function from consuming all capacity</p> </li> <li> <p>Monitor and Adjust:</p> </li> <li>Watch ConcurrentExecutions metric</li> <li>Monitor ProvisionedConcurrencySpillover</li> <li>Use Application Auto Scaling for dynamic workloads</li> </ol>"},{"location":"compute/lambda/#common-issues","title":"Common Issues","text":"<ul> <li>Cold Starts: Solved by Provisioned Concurrency</li> <li>Throttling: Managed by Reserved Concurrency</li> <li>Cost Management: Balance between provisioned instances and on-demand scaling</li> </ul>"},{"location":"database/dynamodb/","title":"Primary key","text":"<ul> <li>must specify primary key when creating a table</li> <li>Two types:</li> <li>partition key: simple primary key, single attribute</li> <li>partition key and sort key: composite primary key, two attributes.</li> </ul>"},{"location":"database/dynamodb/#secondary-indexes","title":"Secondary indexes","text":"<ul> <li>enable to query the data in the table using an alternate key, different from the primary key</li> <li>Two types:</li> <li>Global secondary index: an index with a partition key and a sort key that can be different from those on the table</li> <li>Local secondary index: an index that has the same partition key as the table, but a different sort key.</li> </ul> <p>Quota: 20 global secondary indexes and 5 local secondary indexes per table.</p>"},{"location":"database/dynamodb/#consistency-models","title":"Consistency models","text":"<ul> <li>DynamoDB supports eventually consistent and strongly consistent reads:</li> <li>Eventually consistent reads (DEFAULT):<ul> <li>response not reflect of the recently completely write operations</li> <li>stale data might be returned</li> </ul> </li> <li>Strongly consistent reads:<ul> <li>always reflect all writes that received a successful response prior to the read</li> <li>higher latency and more expensive</li> <li>apply ConsistentRead parameter and set it to true for GetItem, Query, Scan operations.</li> </ul> </li> </ul>"},{"location":"deployment/sam/","title":"AWS SAM","text":"<ul> <li>open-source framework for building serverless applications</li> <li>combinations of Lamba functions, event sources, other resources that work together to perform tasks</li> <li>Transform Parameter is compulsory in SAM template</li> </ul>"},{"location":"general/general/","title":"CodeDeploy - CodeBuild - Code Pipeline","text":"<ul> <li> <p>CodeDeploy:</p> </li> <li> <p>deployment service</p> </li> <li> <p>deploy to EC2 instances, on-premises instances, serverless     lambda</p> </li> <li> <p>2 types of deployments:</p> </li> <li> <p>in-place deployment</p> </li> <li> <p>blue-green deployment:</p> <ul> <li>enables user to verify a new deployment of service before sending production traffic to it</li> <li>provision a new set of instances then reroute traffic</li> </ul> </li> <li> <p>CodeBuild: fully managed CI service that compiles the code, run tests and produces software packages</p> </li> <li> <p>CodePipeline: automates the build, test and deploy phases of release process everytime there is a code change</p> </li> </ul>"},{"location":"general/must-review/","title":"Network","text":"<ul> <li>Security Group</li> <li>Network ACLs</li> <li>stateful vs stateless</li> </ul>"},{"location":"integration/step-functions/","title":"AWS Step Function","text":"<ul> <li>serverless function orchestrator</li> <li>sequence AWS Lambda functions and multiple AWS services into business-critical applications</li> </ul>"},{"location":"integration/step-functions/#consideration","title":"Consideration","text":"<p>When to use Step Functions:</p> <ul> <li>highly scalable, auditable, and distributed applications</li> <li>support keep track of all tasks and events</li> </ul> <p>When to use SQS:</p> <ul> <li>reliable, highly-scalable queue for storing, sending, and receiving messages between distributed application components</li> <li>need to implement applicaiton-level tracking</li> </ul>"},{"location":"load-balancing/load-balancers/","title":"cross-zone load balancing","text":"<ul> <li>by default, load balancer routes traffic to all registered instances in all enabled AZs</li> <li>Eg: 2 AZs, 2 in Zone A, 8 in Zone B   If no cross-zone load balancing:</li> <li>Zone A: each instance gets 50%/2 = 25%</li> <li>Zone B: each instance gets 50%/8 = 6.25%</li> </ul> <p>If cross-zone load balancing enabled:</p> <ul> <li>Zone A: each instance gets 100%/10 = 10%</li> <li> <p>Zone B: each instance gets 100%/10 = 10%</p> </li> <li> <p>cross-zone load balancing is enabled by default for Application Load Balancer</p> </li> <li>cross-zone load balancing is disabled by default for Network Load Balancer</li> <li>cross-zone load balancing is not available for Classic Load Balancer</li> </ul>"},{"location":"messaging/sqs/","title":"SQS","text":""},{"location":"messaging/sqs/#key-points-to-remember","title":"Key Points to Remember","text":"<ul> <li>Two types of queues:</li> <li>Standard Queue: At-least-once delivery, best-effort ordering</li> <li>FIFO Queue: Exactly-once processing, strict ordering</li> <li>Default retention period: 4 days (Configurable from 1 minute to 14 days)</li> <li>Maximum message size: 256KB</li> <li>Long polling vs Short polling:</li> <li>Long polling (1-20 seconds): Reduces API calls, recommended for cost savings</li> <li>Short polling (0 seconds): Immediate response, more API calls</li> <li>Visibility Timeout:</li> <li>Default: 30 seconds</li> <li>Min: 0 seconds</li> <li>Max: 12 hours</li> <li>Can be changed using ChangeMessageVisibility API</li> </ul>"},{"location":"messaging/sqs/#message-lifecycle","title":"Message Lifecycle","text":"<ol> <li>Producer sends message</li> <li>Message is redundantly distributed</li> <li>Consumer receives message (becomes invisible to other consumers)</li> <li>Message is processed</li> <li>Message is deleted by consumer</li> <li>If not deleted before visibility timeout, message becomes visible again</li> </ol>"},{"location":"messaging/sqs/#important-quotas-limits","title":"Important Quotas &amp; Limits","text":"<ul> <li>In-flight messages (messages being processed):</li> <li>Standard queue: 120,000 messages per queue</li> <li>FIFO queue: 20,000 messages per queue</li> <li>Message retention: 1 minute to 14 days (default: 4 days)</li> <li>Delay queue: 0 seconds to 15 minutes</li> <li>Message size: 1 byte to 256KB</li> <li>Queue name: 80 characters maximum</li> <li>Maximum receives per message: 1,000 messages per API call</li> <li>FIFO Queue specific:</li> <li>Maximum throughput: 300 messages/second (with batching)</li> <li>3,000 messages per second with batching using multiple message group IDs</li> <li>Messages must have a Message Group ID</li> <li>Deduplication ID required (either provided or content-based)</li> <li>Queue name must end with .fifo suffix</li> </ul>"},{"location":"messaging/sqs/#best-practices","title":"Best Practices","text":"<ul> <li>Use Long Polling when possible (reduces costs)</li> <li>Set appropriate visibility timeout based on processing time</li> <li>Always delete messages after successful processing</li> <li>Use batch operations when possible (SendMessageBatch, DeleteMessageBatch)</li> <li>For ordered messages, use FIFO queues</li> <li>Monitor CloudWatch metrics:</li> <li>ApproximateNumberOfMessagesVisible</li> <li>ApproximateAgeOfOldestMessage</li> <li>ApproximateNumberOfMessagesNotVisible</li> </ul>"},{"location":"networking/api-gateway/","title":"API Gateway","text":"<p>A fully managed service for creating, publishing, maintaining, monitoring, and securing APIs at any scale.</p>"},{"location":"networking/api-gateway/#key-concepts-features","title":"Key Concepts &amp; Features","text":""},{"location":"networking/api-gateway/#api-optimization","title":"API Optimization","text":"<ul> <li>Response Caching: Caches endpoint responses for a specified TTL (Time-To-Live) to reduce the number of calls made to your backend and improve latency.</li> <li>Payload Compression: Compresses response payloads to reduce latency and data transfer costs.</li> </ul>"},{"location":"networking/api-gateway/#api-endpoint-types","title":"API Endpoint Types","text":"<ul> <li>Edge-Optimized: Default. Best for geographically distributed clients. Requests are routed to the nearest CloudFront Point of Presence (POP).</li> <li>Regional: For clients in the same region as the API.</li> <li>Private: Can only be accessed from your Amazon VPC using a VPC endpoint.</li> </ul>"},{"location":"networking/api-gateway/#security","title":"Security","text":"<ul> <li>Authentication &amp; Authorization:</li> <li>IAM: Use AWS IAM roles and policies to authorize access to your APIs.</li> <li>Cognito User Pools: Authenticate users through Cognito.</li> <li>Lambda Authorizers (Custom Authorizers): Use a Lambda function to perform custom authorization logic.</li> <li>API Keys: For tracking and controlling access for specific clients.</li> <li>Throttling &amp; Usage Plans: Protect your backend from traffic spikes by setting rate limits and quotas.</li> </ul>"},{"location":"networking/api-gateway/#integrations","title":"Integrations","text":"<ul> <li>VPC Links: Connect your API Gateway to private resources within a VPC, like Application Load Balancers or EC2 instances, without exposing them to the public internet.</li> <li>AWS Service Integrations: Directly integrate with other AWS services (e.g., Lambda, DynamoDB, S3). For example, you can have an API endpoint that directly reads from a DynamoDB table.</li> </ul>"},{"location":"networking/api-gateway/#important-notes","title":"Important Notes","text":"<ul> <li>ElastiCache: This is a downstream service. While it can cache data for your backend (e.g., a Lambda function), it does not cache the API Gateway responses themselves. Use API Gateway's built-in caching for that.</li> <li>API Gateway VPC Endpoint: This allows resources within your VPC to securely access your Private APIs without using an internet gateway.</li> </ul>"},{"location":"networking/cloudfront/","title":"Sign URLs and Cookies","text":"<ul> <li>Use signed URLs and signed cookies to control access to content.</li> </ul>"},{"location":"networking/cloudfront/#cloudfront-key-pairs","title":"CloudFront Key Pairs","text":"<ul> <li>create signed URLS ans signed cookies</li> <li>Only AWS account root user can manage CloudFront key pairs</li> <li>Each account can have up to 2 ACTIVE key pairs</li> <li>Key pairs:</li> <li>Public key: CF uses to verify URL signatures</li> <li>Private key: user use to sign URLS</li> <li>Cannot use IAM roles to manage CF key pairs</li> </ul>"},{"location":"networking/cloudfront/#step","title":"Step","text":"<ul> <li>Root user creates key pair in AWS console</li> <li>Download .pem file (private key)</li> <li>Upload public key to CF</li> <li>Associate public key with trusted signer (AWS account or CloudFront OAI)</li> </ul>"},{"location":"networking/route53/","title":"Comparison of alias and CNAME records","text":"<ul> <li>Alias record only redirect to selected AWS resources (CloudFront, S3 static website hosting, Elastic Beanstalk, API Gateway, VPC endpoint, Global Accelerator), or orther record in the same Route53 hosted zone</li> <li> <p>Can create an alias record that has the same name as hosted zone (root domain)</p> </li> <li> <p>CNAME record can redirect to any URL, including AWS resources and external domains</p> </li> <li> <p>Cannot create a CNAME record that has the same name as hosted zone (root domain).</p> </li> <li> <p>Pricing: Alias record is free, CNAME record is charged as standard Route53 queries</p> </li> </ul>"},{"location":"scaling/auto-scaling-groups/","title":"Definition","text":"<ul> <li>An Auto Scaling group contains a collection of Amazon EC2 instances that span multiple Availability Zones in a region. (not multiple regions)</li> </ul>"},{"location":"security/cognito/","title":"Amazon Cognito","text":""},{"location":"security/cognito/#user-pools-vs-identity-pools-comparison","title":"User Pools vs Identity Pools Comparison","text":"Feature User Pools Identity Pools Primary Purpose User directory and authentication Temporary AWS credentials and authorization Main Function Manages user sign-up/sign-in Provides AWS service access Authentication Type Username/password, social identity, SAML Supports anonymous users and authenticated users from various sources Output JWT tokens (ID, Access, Refresh) Temporary AWS credentials (IAM roles) Common Use Cases - Web/mobile app authentication- User profile management- MFA and password policies - Access AWS services (S3, DynamoDB)- Fine-grained authorization- Anonymous user access Identity Type Authentication (Who are you?) Authorization (What can you do?) Best For - User management- Social sign-in- Custom auth flows - AWS service access- Role-based access- Guest access"},{"location":"security/cognito/#key-points-to-remember","title":"Key Points to Remember","text":"<ul> <li>User Pools = Authentication (Identity verification)</li> <li>Identity Pools = Authorization (AWS service access)</li> <li>They can work together: User Pools can be an identity provider for Identity Pools</li> <li>Identity Pools can use other identity providers too (Google, Facebook, etc.)</li> </ul>"},{"location":"security/cognito/#detailed-features","title":"Detailed Features","text":""},{"location":"security/cognito/#user-pools","title":"User Pools","text":"<ul> <li>User directory in Amazon Cognito</li> <li>Provides sign-up and sign-in options for your app users</li> <li>Features:</li> <li>Built-in customizable UI for sign-in</li> <li>Social sign-in with third party: Facebook, Amazon, Google, Apple</li> <li>MFA, phone/email verification</li> <li>Customizable workflows with AWS Lambda triggers</li> </ul>"},{"location":"security/cognito/#identity-pools","title":"Identity Pools","text":"<ul> <li>Create unique identities and federate them with identity providers</li> <li>Obtain temporary, limited-privilege AWS credentials</li> <li>Supports:</li> <li>Amazon Cognito user pools</li> <li>Open ID Connect (OIDC) providers</li> <li>SAML Identity providers</li> <li>Developer Authenticated identities</li> <li> <p>Note: To save user information, identity pools need to be integrated with user pools</p> </li> <li> <p>We can create an identity based policy that allows Amazon Cognito users to access specific AWS resources like S3 or DynamoDB.</p> </li> </ul>"},{"location":"security/iam/","title":"AWS Account root user","text":"<ul> <li>IAM users cannot create CloudFront key pairs -&gt; must log in using root credentials to create ones</li> </ul>"},{"location":"security/iam/#codecommit","title":"CodeCommit","text":"<ul> <li>Cannot use IAM username and password for CodeCommit</li> </ul>"},{"location":"security/iam/#billing-and-cost-management","title":"Billing and Cost Management","text":"<ul> <li>By default, IAM users DO NOT have access to AWS Billing and Cost management</li> <li>Need:</li> <li>account admin to grant access to IAM user.</li> <li>activate IAM user access to the billing and cost management console and attach IAM policy to users</li> <li>then need to activate IAM user access for IAM policies to take effect</li> </ul>"},{"location":"security-networking/https/","title":"Enable HTTPS connection","text":"<ul> <li>Deploy SSL/TLS server certificate:</li> <li>ACM: provision, manage and deploy server certificates. In supported Regions, you can request a certificate directly from ACM.</li> <li>IAM: when support HTTPS connection in unsupported ACM Regions. Encrypted private keys and stores in IAM SSL Certificate Store. Supports deploying server certificates in all Regions, but you must otain the certificate from a third-party CA.</li> </ul>"},{"location":"security-networking/security-groups-nacls/","title":"Security Group","text":"<ul> <li>SG is stateful</li> <li>Allowing inbound traffic automatically allows the response outbound traffic</li> <li>By default, SG denies all inbound traffic and allows all outbound traffic</li> <li>Can only allow rules, cannot create deny rules</li> </ul>"},{"location":"security-networking/security-groups-nacls/#network-acls","title":"Network ACLs","text":"<ul> <li>NACL is stateless</li> <li>Must create rules to allow both inbound and outbound traffic</li> <li>By default, NACL allows all inbound and outbound traffic</li> <li>Can create both allow and deny rules</li> <li>Each rule has a number, lower number has higher priority</li> <li>If no rule matches, the default action is to deny</li> </ul>"},{"location":"storage/s3/","title":"Replication data in S3","text":"<ul> <li>S3 lifecycle actions are not replicated. User must configure lifecycle rules in destination bucket.</li> <li>Same Region Replication (SRR) and Cross-Region Replication (CRR) supported at S3 bucket level</li> </ul>"},{"location":"storage/s3/#encryption-in-s3","title":"Encryption in S3","text":"<ul> <li>SSE-S3 (AES-256 managed by S3):</li> <li>AWS fully manages keys.</li> </ul> <p>You have no control over key creation, rotation, or deletion.</p> <p>Easiest, but not suited here since you want control.</p> <p>SSE-KMS (AWS KMS keys)</p> <p>Keys are managed by AWS KMS.</p> <p>Two types:</p> <p>AWS managed keys (aws/s3): minimal control.</p> <p>Customer managed CMKs (customer created keys): you create keys, set rotation policy, and remove them when needed.</p> <p>Fits your requirement.</p> <p>SSE-C (Customer-provided keys)</p> <p>You manage and provide your own encryption keys.</p> <p>AWS does not store keys.</p> <p>More complex key lifecycle management. Not AWS managed.</p> <p>Client-side encryption</p> <p>You encrypt before uploading.</p> <p>AWS does not manage keys.</p> <p>Full responsibility on your side.</p>"}]}