{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Not Nick dummy notes","text":""},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#compute","title":"Compute","text":"<ul> <li>EC2 - Elastic Compute Cloud</li> <li>Lambda - Serverless Functions</li> <li>Elastic Beanstalk - PaaS Solution</li> </ul>"},{"location":"#storage","title":"Storage","text":"<ul> <li>S3 - Simple Storage Service</li> </ul>"},{"location":"#security","title":"Security","text":"<ul> <li>IAM - Identity and Access Management</li> <li>Cognito - User Authentication and Authorization</li> </ul>"},{"location":"#networking","title":"Networking","text":"<ul> <li>API Gateway - API Management</li> <li>CloudFront - Content Delivery Network</li> <li>Route 53 - DNS Service</li> </ul>"},{"location":"#database","title":"Database","text":"<ul> <li>DynamoDB - NoSQL Database</li> </ul>"},{"location":"#messaging","title":"Messaging","text":"<ul> <li>SQS - Simple Queue Service</li> <li>Kinesis - Real-time Data Streaming</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>Step Functions - Workflow Orchestration</li> </ul>"},{"location":"compute/ebs/","title":"EBS","text":""},{"location":"compute/ebs/#encrypt","title":"Encrypt","text":"<ul> <li>We cannot encrypt an existing unencrypted volume</li> <li>Create a snapshot of the volume</li> <li>Encrypt the snapshot</li> <li>Create a new volume from the encrypted snapshot</li> <li>Attach the new volume to the instance</li> </ul>"},{"location":"compute/ec2/","title":"EC2 (Elastic Compute Cloud)","text":""},{"location":"compute/ec2/#instance-types","title":"Instance Types","text":"<p>General Purpose: T3, T4g, M5, M6i Compute Optimized: C5, C6i Memory Optimized: R5, X1e Storage Optimized: I3, D3 Accelerated Computing: P4, G4</p>"},{"location":"compute/ec2/#tenancy-options","title":"Tenancy Options","text":"Shared (Default) Multiple customers share physical hardware Dedicated Instance Hardware dedicated to your account, may share with other instances in same account Dedicated Host Physical server completely dedicated to you, bring your own license (BYOL)"},{"location":"compute/ec2/#pricing-models","title":"Pricing Models","text":"<ul> <li>On-Demand: Pay per hour/second, no commitment</li> <li>Reserved: 1-3 year commitment, up to 75% savings</li> <li>Spot: Unused capacity, up to 90% savings, can be interrupted</li> <li>Savings Plans: Flexible pricing for consistent usage</li> </ul>"},{"location":"compute/ec2/#key-features","title":"Key Features","text":"<ul> <li>Auto Scaling: Automatically adjust capacity</li> <li>Load Balancing: Distribute traffic across instances</li> <li>Security Groups: Virtual firewalls</li> <li>Key Pairs: SSH access (Linux) / RDP access (Windows)</li> <li>User Data: Bootstrap scripts at launch</li> </ul>"},{"location":"compute/ec2/#free-tier","title":"Free Tier","text":"<ul> <li>t2.micro or t3.micro (1 vCPU, 1GB RAM)</li> <li>750 hours/month for first 12 months</li> <li>Linux/Windows eligible</li> </ul>"},{"location":"compute/ec2/#query-metadata-for-instance","title":"Query metadata for instance","text":"<ul> <li>Query the metadata at http://169.254.169.254/latest/meta-data</li> </ul>"},{"location":"compute/ec2/#use-case-notes","title":"Use case notes","text":"<ol> <li> <p>Bussiness application is hosted on EC2 isntances. The business has requested a solution to track average response time, and send a notification to the admin if it exceeds a threadhold    -&gt; Can use CloudWatch and SNS</p> </li> <li> <p>Configure application write the response time to a log file.</p> </li> <li>Install and config CloudWatch agent on the EC2 instances to monitor the log file and send the data to CloudWatch Logs</li> <li> <p>Create a CloudWatch alarm to send an Amazon Simple Notification Service (Amazon SNS) notification when the average of the response time metric exceeds the threshold</p> </li> <li> <p>How to disable the attribute 'DeleteOnTermination' for root EBS volume while the EC2 is running    -&gt; AWS Console does not allow -&gt; can use AWS CLI or SDK</p> </li> </ol>"},{"location":"compute/elastic-beanstalk/","title":"Elastic Beanstalk","text":""},{"location":"compute/elastic-beanstalk/#overview","title":"Overview","text":"<p>PaaS (Platform as a Service) - Deploy applications without managing infrastructure Supported Languages: Java, .NET, PHP, Node.js, Python, Ruby, Go, Docker Handles: Load balancing, auto-scaling, monitoring, patching</p>"},{"location":"compute/elastic-beanstalk/#deployment-policies","title":"Deployment Policies","text":"Policy Downtime Risk Speed Best For All at Once Yes High Fastest Dev/Test Rolling No Medium Moderate Production Rolling + Batch No Low Slow Production (maintain capacity) Immutable No Very Low Slower Critical production Blue/Green No Very Low Slowest Mission-critical <p>All at Once - Deploy to all instances simultaneously - Has downtime, fastest deployment</p> <p>Rolling - Deploy in batches, reduced capacity during deployment - No downtime, some instances serve old version</p> <p>Rolling with Additional Batch - Launch new instances first, then deploy in batches - Maintains full capacity, longer deployment time</p> <p>Immutable - Launch new instances with new version - Zero downtime, quick rollback, higher cost</p> <p>Blue/Green - Create new environment, swap URLs - Zero downtime, instant rollback, requires Route 53</p>"},{"location":"compute/elastic-beanstalk/#components","title":"Components","text":"<ul> <li>Application: Collection of components (environments, versions)</li> <li>Application Version: Deployable code</li> <li>Environment: Running application version</li> <li>Configuration Template: Environment settings template</li> </ul>"},{"location":"compute/elastic-beanstalk/#key-features","title":"Key Features","text":"<ul> <li>Auto Scaling: Automatically adjust capacity</li> <li>Load Balancer: Distribute traffic</li> <li>Health Monitoring: Application and instance health</li> <li>Version Management: Track application versions</li> <li>Log Collection: Centralized logging</li> </ul>"},{"location":"compute/elastic-beanstalk/#configuration","title":"Configuration","text":"<ul> <li>.ebextensions: YAML/JSON files in source code</li> <li>Environment Variables: Runtime configuration</li> <li>Configuration Files: Infrastructure settings</li> <li>Saved Configurations: Reusable environment templates</li> </ul>"},{"location":"compute/elastic-beanstalk/#supported-platforms","title":"Supported Platforms","text":"<ul> <li>Web Servers: Apache, Nginx, IIS</li> <li>Application Servers: Tomcat, Passenger, Puma</li> <li>Docker: Single/multi-container</li> </ul>"},{"location":"compute/lambda/","title":"Lambda","text":""},{"location":"compute/lambda/#core-concepts","title":"Core Concepts","text":"<p>Serverless compute - Run code without managing servers Event-driven - Triggered by events from AWS services Pay-per-request - Only pay for compute time used Auto-scaling - Handles scaling automatically</p>"},{"location":"compute/lambda/#key-limits","title":"Key Limits","text":"<ul> <li>Memory: 128MB - 10,240MB (1MB increments)</li> <li>CPU: Allocated proportionally to memory (can't set directly)</li> <li>Timeout: 15 minutes max</li> <li>Payload: 6MB synchronous, 256KB asynchronous</li> <li>Deployment package: 50MB zipped, 250MB unzipped</li> <li>Concurrent executions: 1,000 per region (soft limit)</li> </ul>"},{"location":"compute/lambda/#concurrency-types","title":"Concurrency Types","text":"Type Purpose Cost Auto Scaling Reserved Limit max concurrency Free No Provisioned Pre-warm instances Pay for capacity Yes Reserved Concurrency Sets ceiling for concurrent executions   Prevents function from consuming all account capacity   Applied to entire function Provisioned Concurrency Pre-initializes instances to eliminate cold starts   Applied to specific version/alias   Can auto-scale based on schedule/utilization"},{"location":"compute/lambda/#triggers","title":"Triggers","text":"<ul> <li>API Gateway: HTTP requests</li> <li>S3: Object events</li> <li>DynamoDB: Stream events</li> <li>SQS/SNS: Message events</li> <li>CloudWatch Events: Scheduled events</li> <li>Application Load Balancer: HTTP requests</li> </ul>"},{"location":"compute/lambda/#deployment","title":"Deployment","text":"<ul> <li>Deployment package: ZIP file with code</li> <li>Container images: Up to 10GB</li> <li>Layers: Share code/libraries across functions</li> <li>Versions: Immutable snapshots</li> <li>Aliases: Mutable pointers to versions</li> </ul>"},{"location":"compute/lambda/#environment-variables","title":"Environment Variables","text":"<ul> <li>Key-value pairs available to function</li> <li>Can be encrypted with KMS</li> <li>Useful for configuration without code changes</li> <li>Total size: 4KB</li> <li>There is no limit to the number of env variables</li> </ul>"},{"location":"compute/lambda/#best-practices","title":"Best Practices","text":"<ul> <li>Keep functions small and focused</li> <li>Use environment variables for config</li> <li>Implement proper error handling</li> <li>Monitor with CloudWatch metrics</li> <li>Use provisioned concurrency for latency-critical workloads<ul> <li>help remove the cold start </li> <li>keep a fixed number of instance always warm: initialize the exec env before the request comes in</li> </ul> </li> </ul>"},{"location":"compute/lambda/#good-to-know","title":"Good to Know","text":"<p>Moving Lambda from AWS console to AWS CloudFormation:</p> <ul> <li>Upload all code as a zip to S3, and refer the object in AWS::Lambda::Function block</li> <li>Write AWS Lambda code inline in CloudFormation in AWS::Lambda::Function block as long as there are no 3rd-party dependencies</li> </ul>"},{"location":"database/dynamodb/","title":"DynamoDB","text":""},{"location":"database/dynamodb/#overview","title":"Overview","text":"<p>NoSQL database - Fast, flexible, serverless database service Fully managed - No servers to manage, automatic scaling Single-digit millisecond latency - High-performance at any scale Global distribution - Multi-region replication available</p>"},{"location":"database/dynamodb/#core-concepts","title":"Core Concepts","text":"Table Collection of data items   Schema-free except for primary key   Automatically partitions data across multiple servers Item Individual record in table   Collection of attributes   Maximum size: 400KB per item Attribute Basic data element   Name-value pair   Scalar, document, or set data types"},{"location":"database/dynamodb/#primary-keys","title":"Primary Keys","text":"Partition Key (Simple Primary Key) Single attribute primary key   Must be unique across all items   Used for data distribution across partitions Partition Key + Sort Key (Composite Primary Key) Two-attribute primary key   Partition key groups items, sort key orders within partition   Combination must be unique"},{"location":"database/dynamodb/#data-types","title":"Data Types","text":"<p>Scalar Types - String (S): Unicode text - Number (N): Positive/negative numbers - Binary (B): Binary data - Boolean (BOOL): True or false - Null (NULL): Unknown or undefined state</p> <p>Document Types - List (L): Ordered collection of values - Map (M): Unordered collection of key-value pairs</p> <p>Set Types - String Set (SS): Set of strings - Number Set (NS): Set of numbers - Binary Set (BS): Set of binary values</p>"},{"location":"database/dynamodb/#secondary-indexes","title":"Secondary Indexes","text":"Index Type Partition Key Sort Key Projection Use Case Global Secondary Index (GSI) Different from table Optional, different from table Configurable Query different access patterns Local Secondary Index (LSI) Same as table Different from table Configurable Additional sort orders <p>GSI Limits: 20 per table LSI Limits: 5 per table (must be created at table creation)</p> Projection Options Keys Only - Only key attributes   Include - Keys plus specified attributes   All - All attributes (highest cost)"},{"location":"database/dynamodb/#consistency-models","title":"Consistency Models","text":"Eventually Consistent Reads (Default) May not reflect most recent write operation   Lower latency and cost   Default for all read operations Strongly Consistent Reads Always return most recent data   Higher latency and cost   Use <code>ConsistentRead=true</code> parameter   Not available for GSI queries"},{"location":"database/dynamodb/#capacity-modes","title":"Capacity Modes","text":"Mode Scaling Pricing Best For On-Demand Automatic Pay per request Unpredictable workloads Provisioned Manual/Auto Scaling Pay for capacity Predictable workloads Read Capacity Units (RCU) 1 RCU = 1 strongly consistent read/sec for item up to 4KB   1 RCU = 2 eventually consistent reads/sec for item up to 4KB Write Capacity Units (WCU) 1 WCU = 1 write/sec for item up to 1KB"},{"location":"database/dynamodb/#dynamodb-streams","title":"DynamoDB Streams","text":"<p>Purpose: Capture data modification events in tables Retention: 24 hours Ordering: Records appear in same sequence as modifications Integration: Trigger Lambda functions for real-time processing</p> <p>Stream Record Types - KEYS_ONLY: Only key attributes of modified item - NEW_IMAGE: Entire item after modification - OLD_IMAGE: Entire item before modification - NEW_AND_OLD_IMAGES: Both new and old images</p>"},{"location":"database/dynamodb/#global-tables","title":"Global Tables","text":"<p>Multi-region replication - Automatically replicate across regions Multi-active - Read and write in any region Conflict resolution - Last writer wins Requirements: DynamoDB Streams must be enabled</p>"},{"location":"database/dynamodb/#dax-dynamodb-accelerator","title":"DAX (DynamoDB Accelerator)","text":"<p>In-memory cache - Microsecond latency for DynamoDB Fully managed - No cache management required Write-through cache - Consistent with DynamoDB Cluster-based - Multi-AZ for high availability</p>"},{"location":"database/dynamodb/#dynamodb-transactions","title":"DynamoDB Transactions","text":"<p>ACID Properties - Atomic, consistent, isolated, durable operations TransactWriteItems - Up to 100 write actions across multiple tables TransactReadItems - Up to 100 read actions with snapshot isolation Additional Cost - 2x the normal consumed capacity</p>"},{"location":"database/dynamodb/#query-operations","title":"Query Operations","text":"Query Retrieve items with same partition key   Can filter by sort key   More efficient than Scan   Returns sorted results Scan Examine every item in table   Can apply filter expressions   Less efficient, higher cost   Parallel scan available for performance Batch Operations BatchGetItem - Retrieve up to 100 items   BatchWriteItem - Put/delete up to 25 items"},{"location":"database/dynamodb/#error-handling","title":"Error Handling","text":"<p>Exponential Backoff - Retry with progressively longer delays ProvisionedThroughputExceededException - Throttling due to capacity limits ConditionalCheckFailedException - Conditional write failed ValidationException - Invalid request parameters</p>"},{"location":"database/dynamodb/#best-practices","title":"Best Practices","text":"<ul> <li>Design primary key for even data distribution</li> <li>Use sort keys for querying patterns</li> <li>Avoid hot partitions by distributing access</li> <li>Use sparse indexes to reduce costs</li> <li>Implement pagination for large result sets</li> <li>Use batch operations when possible</li> <li>Monitor consumed capacity with CloudWatch</li> <li>Use DynamoDB Accelerator (DAX) for read-heavy workloads</li> <li>Design for eventually consistent reads when possible</li> </ul>"},{"location":"database/rds/","title":"RDS Notes","text":""},{"location":"database/rds/#authentication","title":"Authentication","text":"<ul> <li>You can authenticate to your DB instance using AWS Identity and Access Management (IAM) database authentication</li> <li>DB Supported: MySQL, PostgreSQL, and MariaDB</li> </ul>"},{"location":"debug/xray/","title":"X-Ray","text":""},{"location":"debug/xray/#x-ray-with-aws-fargate","title":"X-Ray with AWS Fargate","text":""},{"location":"debug/xray/#setup","title":"Setup","text":"<ul> <li>Provide IAM task role to X-Ray container</li> <li>Deploy X-Ray daemon as sidecar container</li> </ul>"},{"location":"debug/xray/#sdk","title":"SDK","text":"<p>AWS_XRAY_DAEMON_ADDRESS</p> <ul> <li>Set the host and port of the X-Ray daemon listener.</li> <li>By default, the SDK uses 127.0.0.1:2000 for both trace data (UDP) and sampling (TCP).</li> <li>Use this variable if you have configured the daemon to listen on a different port or if it is running on a different host</li> </ul>"},{"location":"debug/xray/#sampling","title":"Sampling","text":"<ul> <li>Sampling rules determine which requests to trace</li> <li>Default rule: 1 request per second, 5% of additional requests</li> <li>Custom rules can be created and prioritized</li> <li>Sampling can be disabled in SDK configuration</li> </ul>"},{"location":"debug/xray/#indexing","title":"Indexing","text":"<ul> <li>Indexes are created for trace data to enable searching</li> <li>Instrumentation: annotation</li> </ul>"},{"location":"deployment/sam/","title":"AWS SAM","text":"<ul> <li>open-source framework for building serverless applications</li> <li>combinations of Lamba functions, event sources, other resources that work together to perform tasks</li> <li>Transform Parameter is compulsory in SAM template</li> </ul>"},{"location":"general/general/","title":"CodeDeploy - CodeBuild - Code Pipeline","text":"<ul> <li> <p>CodeDeploy:</p> </li> <li> <p>deployment service</p> </li> <li> <p>deploy to EC2 instances, on-premises instances, serverless     lambda</p> </li> <li> <p>2 types of deployments:</p> </li> <li> <p>in-place deployment</p> </li> <li> <p>blue-green deployment:</p> <ul> <li>enables user to verify a new deployment of service before sending production traffic to it</li> <li>provision a new set of instances then reroute traffic</li> </ul> </li> <li> <p>CodeBuild: fully managed CI service that compiles the code, run tests and produces software packages</p> </li> <li> <p>CodePipeline: automates the build, test and deploy phases of release process everytime there is a code change</p> </li> </ul>"},{"location":"general/must-review/","title":"Network","text":"<ul> <li>Security Group</li> <li>Network ACLs</li> <li>stateful vs stateless</li> </ul>"},{"location":"integration/step-functions/","title":"Step Functions","text":""},{"location":"integration/step-functions/#overview","title":"Overview","text":"<p>Serverless workflow orchestration - Coordinate distributed applications and microservices Visual workflows - Define business logic using visual workflows AWS service integration - Connect AWS services without custom code Built-in error handling - Automatic retry, catch, and rollback capabilities</p>"},{"location":"integration/step-functions/#core-concepts","title":"Core Concepts","text":"State Machine JSON-based workflow definition (Amazon States Language)   Contains states that define workflow logic   Can be Standard or Express workflows State Individual step in workflow   Performs work, makes decisions, or waits   Receives input, processes it, and produces output Execution Instance of state machine processing input   Each execution has unique name and status   Can be monitored and debugged individually"},{"location":"integration/step-functions/#workflow-types","title":"Workflow Types","text":"Type Use Case Duration Execution History Pricing Standard Long-running processes Up to 1 year Full history kept Per state transition Express High-volume, short-duration Up to 5 minutes CloudWatch Logs Per execution + duration"},{"location":"integration/step-functions/#state-types","title":"State Types","text":"Pass Transform input data or inject fixed data   Useful for testing and data manipulation   No work performed, just data transformation Task Single unit of work performed by AWS service   Lambda function, ECS task, SNS message, etc.   Can include retry and error handling Choice Branching logic based on input conditions   Multiple conditional branches   Default branch for unmatched conditions Wait Delay workflow for specified time   Seconds, timestamp, or seconds path   Useful for rate limiting or scheduled tasks Parallel Execute multiple branches simultaneously   All branches must complete successfully   Results combined into single array Map Process array of items in parallel   Execute same logic for each array item   Configurable concurrency limits Succeed/Fail Terminal states to end execution   Succeed: successful completion   Fail: error termination with cause/error"},{"location":"integration/step-functions/#error-handling","title":"Error Handling","text":"Retry Automatic retry on errors   Configurable retry count and backoff   Supports exponential backoff and jitter Catch Handle specific error types   Redirect to different state on error   Can preserve error information <p>Error Types - <code>States.ALL</code>: Catch all errors - <code>States.Timeout</code>: Task timeout - <code>States.TaskFailed</code>: Task execution failed - <code>States.Permissions</code>: Insufficient permissions - Custom error names from Lambda functions</p>"},{"location":"integration/step-functions/#aws-service-integrations","title":"AWS Service Integrations","text":"<p>Optimized Integrations (300+ AWS services) - Lambda: Invoke functions - ECS: Run tasks - SNS/SQS: Send messages - DynamoDB: Read/write data - S3: Object operations - Batch: Submit jobs</p> <p>Service Integration Patterns - Request Response: Synchronous, wait for completion - Run a Job (.sync): Wait for job completion - Wait for Callback (.waitForTaskToken): Wait for external callback</p>"},{"location":"integration/step-functions/#inputoutput-processing","title":"Input/Output Processing","text":"<p>InputPath: Select portion of input to pass to state OutputPath: Select portion of output to return ResultPath: Where to place result in output Parameters: Create new input using input data and literal values</p>"},{"location":"integration/step-functions/#monitoring-debugging","title":"Monitoring &amp; Debugging","text":"<p>Execution History: Detailed log of all state transitions CloudWatch Integration: Metrics and logs for monitoring X-Ray Tracing: Distributed tracing across services Visual Console: Graphical execution tracking</p>"},{"location":"integration/step-functions/#use-cases","title":"Use Cases","text":"Data Processing Pipelines ETL workflows with multiple steps   Error handling and retry logic   Coordinate AWS batch jobs Microservices Orchestration Coordinate multiple Lambda functions   Handle inter-service communication   Implement saga patterns Human Approval Workflows Wait for manual approval steps   Send notifications and wait for response   Route based on approval decisions"},{"location":"integration/step-functions/#best-practices","title":"Best Practices","text":"<ul> <li>Keep state machines focused and modular</li> <li>Use appropriate workflow type (Standard vs Express)</li> <li>Implement proper error handling with retry/catch</li> <li>Use InputPath/OutputPath to minimize data transfer</li> <li>Monitor executions with CloudWatch and X-Ray</li> <li>Design for idempotency in all states</li> <li>Use Map state for parallel array processing</li> <li>Keep state machine definitions under version control</li> </ul>"},{"location":"integration/step-functions/#keywords","title":"Keywords","text":"<ul> <li>ochestration service</li> <li>manage and automate workflows</li> </ul>"},{"location":"load-balancing/load-balancers/","title":"cross-zone load balancing","text":"<ul> <li>by default, load balancer routes traffic to all registered instances in all enabled AZs</li> <li>Eg: 2 AZs, 2 in Zone A, 8 in Zone B   If no cross-zone load balancing:</li> <li>Zone A: each instance gets 50%/2 = 25%</li> <li>Zone B: each instance gets 50%/8 = 6.25%</li> </ul> <p>If cross-zone load balancing enabled:</p> <ul> <li>Zone A: each instance gets 100%/10 = 10%</li> <li> <p>Zone B: each instance gets 100%/10 = 10%</p> </li> <li> <p>cross-zone load balancing is enabled by default for Application Load Balancer</p> </li> <li>cross-zone load balancing is disabled by default for Network Load Balancer</li> <li>cross-zone load balancing is not available for Classic Load Balancer</li> </ul>"},{"location":"messaging/kinesis/","title":"Kinesis","text":""},{"location":"messaging/kinesis/#overview","title":"Overview","text":"<p>Real-time data streaming - Collect, process, and analyze data in real-time Fully managed - No infrastructure to manage Scalable - Handle any amount of streaming data Multiple services - Different tools for different use cases</p>"},{"location":"messaging/kinesis/#kinesis-services","title":"Kinesis Services","text":"Service Purpose Use Case Data Streams Real-time data streaming Custom applications, real-time analytics Data Firehose Data delivery to storage ETL, data lakes, analytics Data Analytics SQL on streaming data Real-time dashboards, alerts Video Streams Video streaming Live video processing, ML analysis"},{"location":"messaging/kinesis/#kinesis-data-streams","title":"Kinesis Data Streams","text":"Shard Basic unit of capacity   1 MB/sec or 1,000 records/sec input   2 MB/sec output   Each record has partition key and sequence number Stream Collection of shards   Scales by adding/removing shards   Retains data for 1-365 days (default: 24 hours) Producer Sends data records to stream   AWS SDK, Kinesis Producer Library (KPL)   Partition key determines which shard receives record Consumer Processes data from stream   AWS SDK, Kinesis Client Library (KCL)   Can be Lambda, EC2, or other applications"},{"location":"messaging/kinesis/#kinesis-data-firehose","title":"Kinesis Data Firehose","text":"<p>Purpose: Deliver streaming data to destinations Destinations: S3, Redshift, Elasticsearch, Splunk, HTTP endpoints Buffering: Based on size (1MB-128MB) or time (60-900 seconds) Transformation: Optional Lambda function for data transformation</p> <p>Key Features - Automatic scaling - Data compression and encryption - Error record handling - Data format conversion (JSON to Parquet/ORC)</p>"},{"location":"messaging/kinesis/#kinesis-data-analytics","title":"Kinesis Data Analytics","text":"<p>SQL Queries: Standard SQL on streaming data Sources: Kinesis Data Streams, Kinesis Data Firehose Destinations: Kinesis Data Streams, Kinesis Data Firehose, Lambda Windowing: Tumbling, sliding, and session windows</p>"},{"location":"messaging/kinesis/#key-concepts","title":"Key Concepts","text":"Partition Key Determines which shard receives record   Use high-cardinality keys for even distribution   Avoid hot shards with uneven distribution Sequence Number Unique identifier assigned by Kinesis   Increases over time within each shard   Used for ordering and checkpointing Retention Period How long data is stored in stream   1-365 days (default: 24 hours)   Extended retention increases costs"},{"location":"messaging/kinesis/#scaling","title":"Scaling","text":"Resharding Split shards to increase capacity (shard splitting)   Merge shards to decrease capacity (shard merging)   Manual or automatic scaling Enhanced Fan-Out Dedicated throughput per consumer   2 MB/sec per consumer per shard   Lower latency (~70ms vs ~200ms)"},{"location":"messaging/kinesis/#error-handling","title":"Error Handling","text":"<p>Put Errors: Retry with exponential backoff Processing Errors: Use error records handling Shard Iterator Expiration: Refresh iterator regularly Throttling: Increase shards or optimize partition keys</p>"},{"location":"messaging/kinesis/#integration-patterns","title":"Integration Patterns","text":"Lambda Integration Event source mapping triggers Lambda   Batch processing of records   Automatic retry and error handling KCL Applications Multi-language support (Java, Python, .NET, Node.js)   Automatic load balancing across instances   Checkpointing for fault tolerance"},{"location":"messaging/kinesis/#best-practices","title":"Best Practices","text":"<ul> <li>Use high-cardinality partition keys for even distribution</li> <li>Monitor shard-level metrics for hot shards</li> <li>Implement proper error handling and retries</li> <li>Use enhanced fan-out for multiple consumers</li> <li>Consider Data Firehose for simple delivery use cases</li> <li>Size batches appropriately for better throughput</li> <li>Monitor age of oldest record to prevent data loss</li> </ul>"},{"location":"messaging/sqs/","title":"SQS (Simple Queue Service)","text":""},{"location":"messaging/sqs/#overview","title":"Overview","text":"<p>Fully managed message queuing - Reliable, scalable message queue service Decouple components - Separate producers and consumers Two queue types - Standard and FIFO queues Pay-per-use - No upfront costs or minimum fees</p>"},{"location":"messaging/sqs/#queue-types","title":"Queue Types","text":"Feature Standard Queue FIFO Queue Delivery At-least-once delivery Exactly-once processing Ordering Best-effort ordering Strict FIFO ordering Throughput Nearly unlimited 300 messages/sec (3,000 with batching) Duplicates Occasional duplicates No duplicates Name Any name Must end with <code>.fifo</code>"},{"location":"messaging/sqs/#core-concepts","title":"Core Concepts","text":"Message Data sent between applications   Contains body (up to 256KB) and attributes   Includes metadata like timestamps and message ID Queue Buffer between message producers and consumers   Holds messages until they are processed and deleted   Distributed across multiple servers for reliability Visibility Timeout Time message is invisible after being received   Prevents other consumers from processing same message   Default: 30 seconds, Max: 12 hours"},{"location":"messaging/sqs/#message-lifecycle","title":"Message Lifecycle","text":"<ol> <li>Producer sends message to queue</li> <li>Message stored redundantly across multiple servers</li> <li>Consumer receives message (becomes invisible to others)</li> <li>Consumer processes message</li> <li>Consumer deletes message from queue</li> <li>If not deleted, message becomes visible again after timeout</li> </ol>"},{"location":"messaging/sqs/#key-features","title":"Key Features","text":"Dead Letter Queues (DLQ) Handles messages that can't be processed successfully   Configured with main queue, not separate service   Helps debug processing issues Message Attributes Metadata attached to messages   Name-value pairs with data type   Up to 10 attributes per message Delay Queues Postpone delivery of messages   0 seconds to 15 minutes delay   Applied to entire queue <p>Long Polling vs Short Polling</p> Type Wait Time API Calls Cost Use Case Long Polling 1-20 seconds Fewer calls Lower cost Recommended default Short Polling 0 seconds More calls Higher cost Immediate response needed"},{"location":"messaging/sqs/#fifo-queue-features","title":"FIFO Queue Features","text":"<p>Message parameters for FIFO queues:</p> <ul> <li>MessageGroupId (required)</li> </ul> Message Groups Messages with same group ID processed in order   Different groups can be processed in parallel   Group ID required for all FIFO messages Deduplication Prevents duplicate messages within 5-minute window   Uses deduplication ID or content-based deduplication   Automatic with content-based hashing"},{"location":"messaging/sqs/#limits-and-quotas","title":"Limits and Quotas","text":"<p>Message Limits</p> <ul> <li>Size: 1 byte to 256KB per message</li> <li>Retention: 1 minute to 14 days (default: 4 days)</li> <li>Receive count: Track how many times message received</li> <li>In-flight messages: 120,000 (Standard), 20,000 (FIFO)</li> </ul> <p>Queue Limits</p> <ul> <li>Name length: 80 characters maximum</li> <li>Queues per region: 1 million (soft limit)</li> <li>Message batch size: 10 messages per batch</li> <li>API rate: Varies by operation and queue type</li> </ul>"},{"location":"messaging/sqs/#batch-operations","title":"Batch Operations","text":"SendMessageBatch Send up to 10 messages in single request   Reduces API calls and improves throughput   Each message can have different attributes ReceiveMessage Retrieve up to 10 messages at once   Use <code>MaxNumberOfMessages</code> parameter   Long polling recommended DeleteMessageBatch Delete up to 10 messages in single request   Must provide receipt handles   More efficient than individual deletes"},{"location":"messaging/sqs/#security-features","title":"Security Features","text":"Encryption Server-side encryption with SQS-managed keys (SSE-SQS)   AWS KMS encryption (SSE-KMS) for additional control   In-transit encryption via HTTPS Access Control IAM policies for user/role-based access   SQS resource-based policies   Condition keys for fine-grained control"},{"location":"messaging/sqs/#error-handling","title":"Error Handling","text":"Message Visibility Change visibility timeout with <code>ChangeMessageVisibility</code> Extend processing time or make immediately visible   Handle processing failures gracefully Redrive Policy Automatically move failed messages to DLQ   Configure maximum receive count   Analyze failures without losing messages"},{"location":"messaging/sqs/#cloudwatch-integration","title":"CloudWatch Integration","text":"<p>Metrics Available</p> <ul> <li><code>ApproximateNumberOfMessages</code>: Messages available</li> <li><code>ApproximateNumberOfMessagesVisible</code>: Messages not being processed</li> <li><code>ApproximateAgeOfOldestMessage</code>: Age of oldest message</li> <li><code>NumberOfMessagesSent</code>: Messages added to queue</li> <li><code>NumberOfMessagesReceived</code>: Messages retrieved</li> <li><code>NumberOfMessagesDeleted</code>: Messages removed</li> </ul>"},{"location":"messaging/sqs/#best-practices","title":"Best Practices","text":"<ul> <li>Use long polling to reduce costs and improve efficiency</li> <li>Set appropriate visibility timeout based on processing time</li> <li>Always delete messages after successful processing</li> <li>Use batch operations when processing multiple messages</li> <li>Implement dead letter queues for error handling</li> <li>Monitor queue depth and message age with CloudWatch</li> <li>Use FIFO queues only when strict ordering is required</li> <li>Design for idempotent message processing</li> <li>Configure appropriate retention periods for your use case</li> </ul>"},{"location":"messaging/sqs/#note","title":"Note","text":"<ul> <li>To manage large Amazon Simple Queue Service (Amazon SQS) messages, you can use Amazon Simple Storage Service (Amazon S3) and the Amazon SQS Extended Client Library for Java. This is especially useful for storing and consuming messages up to 2 GB. Unless your application requires repeatedly creating queues and leaving them inactive or storing large amounts of data in your queues, consider using Amazon S3 for storing your data.</li> </ul>"},{"location":"networking/api-gateway/","title":"API Gateway","text":""},{"location":"networking/api-gateway/#overview","title":"Overview","text":"<p>Fully managed API service - Create, publish, maintain, monitor, and secure APIs Any scale - Handle thousands of concurrent API calls Multiple protocols - REST APIs, HTTP APIs, WebSocket APIs Pay-per-use - No upfront costs or minimum fees</p>"},{"location":"networking/api-gateway/#api-types","title":"API Types","text":"Type Best For Features Cost REST API Full feature set, legacy systems Caching, request validation, SDK generation Higher HTTP API Modern applications, lower latency JWT authorization, CORS Lower (up to 70% cost reduction) WebSocket API Real-time communication Bidirectional communication Pay per message"},{"location":"networking/api-gateway/#endpoint-types","title":"Endpoint Types","text":"Edge-Optimized (Default) Requests routed to nearest CloudFront edge location   Best for geographically distributed clients   Uses CloudFront network for optimization Regional For clients in same region as API   Lower latency for regional clients   Can combine with your own CloudFront distribution Private Accessible only from your VPC   Uses VPC endpoints for secure access   Not exposed to public internet"},{"location":"networking/api-gateway/#security-authorization","title":"Security &amp; Authorization","text":"<p>Authentication Methods - AWS IAM: Use IAM roles and policies - Cognito User Pools: Integrate with Cognito for user authentication - Lambda Authorizers: Custom authorization logic with Lambda - API Keys: Simple client identification and usage tracking</p> <p>Additional Security - Resource policies: Control access to API resources - CORS: Cross-origin resource sharing configuration - Certificate management: SSL/TLS certificates for custom domains</p>"},{"location":"networking/api-gateway/#requestresponse-features","title":"Request/Response Features","text":"Request Validation Validate request parameters and body   Reduce backend processing load   Return validation errors immediately Request Transformation Modify requests before sending to backend   Map parameters and headers   Change request format Response Transformation Modify responses before returning to client   Transform data format   Add/remove headers"},{"location":"networking/api-gateway/#performance-optimization","title":"Performance &amp; Optimization","text":"Caching Response caching with configurable TTL (Time-To-Live)   Reduces calls to backend services   Improves response times and reduces costs Throttling Rate limiting to protect backend services   Configurable per-client limits   Burst capacity for traffic spikes Usage Plans &amp; API Keys Define throttling and quota limits   Associate with API keys for tracking   Different tiers of service"},{"location":"networking/api-gateway/#integration-types","title":"Integration Types","text":"Lambda Integration Direct integration with Lambda functions   Synchronous and asynchronous invocation   Most common integration pattern HTTP Integration Forward requests to HTTP endpoints   Support for HTTP/HTTPS backends   Can integrate with ALB, NLB AWS Service Integration Direct integration with AWS services   DynamoDB, S3, SNS, SQS without Lambda   Reduces latency and complexity VPC Link Connect to private resources in VPC   Application Load Balancers and Network Load Balancers   Secure communication without internet gateway"},{"location":"networking/api-gateway/#monitoring-logging","title":"Monitoring &amp; Logging","text":"CloudWatch Integration API metrics (latency, errors, request count)   Custom metrics and alarms   Automatic monitoring setup Access Logging Detailed request/response logs   Customizable log format   Integration with CloudWatch Logs AWS X-Ray Distributed tracing   Performance analysis   Error detection and debugging"},{"location":"networking/api-gateway/#limits-quotas","title":"Limits &amp; Quotas","text":"<ul> <li>Payload size: 10MB for REST APIs, 6MB for HTTP APIs</li> <li>Timeout: 29 seconds maximum</li> <li>Rate limits: 10,000 requests per second (default)</li> <li>Burst limits: 5,000 requests (default)</li> <li>API keys: 500 per account per region</li> </ul>"},{"location":"networking/api-gateway/#best-practices","title":"Best Practices","text":"<ul> <li>Use HTTP APIs for new applications when possible</li> <li>Implement proper error handling and status codes</li> <li>Enable caching for frequently accessed data</li> <li>Use throttling to protect backend services</li> <li>Monitor API performance with CloudWatch</li> <li>Implement request validation to reduce backend load</li> <li>Use least privilege principle for IAM policies</li> </ul>"},{"location":"networking/cloudfront/","title":"CloudFront","text":""},{"location":"networking/cloudfront/#overview","title":"Overview","text":"<p>Global content delivery network (CDN) - Deliver content with low latency Edge locations - 450+ points of presence worldwide Caching - Reduce load on origin servers Security - DDoS protection and AWS Shield integration</p>"},{"location":"networking/cloudfront/#key-concepts","title":"Key Concepts","text":"<p>Distribution</p> <ul> <li>Configuration that tells CloudFront where to get content</li> <li>Defines caching behavior and security settings</li> <li>Takes 15-20 minutes to deploy globally</li> </ul> <p>Origin</p> <ul> <li>Source of content (S3 bucket, HTTP server, Application Load Balancer)</li> <li>Can have multiple origins per distribution</li> <li>Failover support with origin groups:</li> <li>Only need 2 origins for setting up origin failover</li> <li>CloudFront fails over to the second origin when HTTP method is GET, HEAD or OPTIONS and the first origin returns 500, 502, 503, or 504 status code</li> <li>Cloudfront route all incoming requests to primary origin, even if previous request was routed to secondary origin</li> </ul> <p>Edge Location - Global cache servers where content is cached - Serves content to users from nearest location - Reduces latency and improves performance</p>"},{"location":"networking/cloudfront/#origins","title":"Origins","text":"Origin Type Use Case Features S3 Bucket Static content, websites Origin Access Control (OAC), versioning support HTTP/HTTPS Dynamic content, APIs Custom headers, SSL verification Application Load Balancer Auto-scaling applications Health checks, multiple targets Media Package Live video streaming Specialized for media content"},{"location":"networking/cloudfront/#caching-behavior","title":"Caching Behavior","text":"<p>TTL (Time-To-Live) - Controls how long objects stay in cache - Default TTL: 24 hours - Can be overridden by Cache-Control headers</p> <p>Cache Key - Determines what makes objects unique in cache - Based on URL path by default - Can include query strings, headers, cookies</p> <p>Cache Policies - Managed policies for common use cases - Control what's included in cache key - Separate from origin request policies</p>"},{"location":"networking/cloudfront/#security-features","title":"Security Features","text":"<p>Signed URLs and Signed Cookies - Control access to private content - Time-based or IP-based restrictions - Requires CloudFront key pairs (root user only)</p> <p>Origin Access Control (OAC) - Secure access to S3 origins - Replaces legacy Origin Access Identity (OAI) - Uses AWS Signature Version 4 for authentication</p> <p>AWS WAF Integration - Web application firewall protection - Filter malicious requests at edge - Custom rules for application protection</p> <p>Field-Level Encryption - Encrypt sensitive data at edge locations - Additional layer beyond HTTPS - Asymmetric encryption for specific fields</p>"},{"location":"networking/cloudfront/#cloudfront-key-pairs","title":"CloudFront Key Pairs","text":"<p>Management Restrictions - Only AWS account root user can create/manage - Cannot use IAM users or roles - Maximum 2 active key pairs per account</p> <p>Components - Public key uploaded to CloudFront - Private key used to sign URLs/cookies - Associate with trusted signers</p> <p>Process</p> <ol> <li>Root user creates key pair in console</li> <li>Download private key (.pem file)</li> <li>Upload public key to CloudFront</li> <li>Associate with distribution as trusted signer</li> </ol>"},{"location":"networking/cloudfront/#performance-features","title":"Performance Features","text":"<p>GZIP Compression - Automatic compression for text-based content - Reduces transfer time and bandwidth costs - Configurable per cache behavior</p> <p>HTTP/2 Support - Modern protocol for improved performance - Multiplexing and header compression - Enabled by default for HTTPS</p> <p>Lambda@Edge - Run code closer to users - Customize content delivery - Four execution points in request/response cycle</p>"},{"location":"networking/cloudfront/#monitoring-analytics","title":"Monitoring &amp; Analytics","text":"<p>Real-Time Logs - Detailed request logs delivered within seconds - Kinesis Data Streams integration - Customizable fields and sampling rates</p> <p>Standard Logs - Detailed access logs - Delivered to S3 bucket - Contains all request details</p> <p>CloudWatch Metrics - Request count, data transfer, error rates - Geographic and device-based metrics - Custom alarms and dashboards</p>"},{"location":"networking/cloudfront/#distribution-types","title":"Distribution Types","text":"<p>Web Distribution (Legacy) - For websites and web applications - HTTP and HTTPS content - Being replaced by unified distributions</p> <p>RTMP Distribution (Deprecated) - For Adobe Flash media streaming - No longer recommended - Use other streaming solutions</p>"},{"location":"networking/cloudfront/#price-classes","title":"Price Classes","text":"<p>Price Class All - All edge locations (best performance) Price Class 100 - North America and Europe only Price Class 200 - North America, Europe, Asia, Middle East, Africa</p>"},{"location":"networking/cloudfront/#best-practices","title":"Best Practices","text":"<ul> <li>Use S3 Transfer Acceleration with CloudFront for global uploads</li> <li>Enable compression for text-based content</li> <li>Configure appropriate cache behaviors for different content types</li> <li>Use Origin Access Control (OAC) instead of OAI for S3 origins</li> <li>Monitor performance with Real-Time Logs</li> <li>Implement signed URLs for private content access</li> <li>Use multiple origins for redundancy and performance</li> <li>Consider Regional Edge Caches for large files</li> </ul>"},{"location":"networking/route53/","title":"Route 53","text":""},{"location":"networking/route53/#overview","title":"Overview","text":"<p>Scalable DNS service - Domain name system with high availability Domain registration - Buy and manage domain names Health checking - Monitor application health and route traffic Global infrastructure - Distributed DNS service worldwide</p>"},{"location":"networking/route53/#core-concepts","title":"Core Concepts","text":"Hosted Zone Container for DNS records for a domain   Public hosted zones for internet traffic   Private hosted zones for VPC internal traffic DNS Records Instructions for DNS queries   Different record types for different purposes   TTL (Time-To-Live) controls caching duration Name Servers Servers that respond to DNS queries   Route 53 provides 4 name servers per hosted zone   Must be configured at domain registrar"},{"location":"networking/route53/#record-types","title":"Record Types","text":"Type Purpose Example A Map domain to IPv4 address example.com \u2192 192.0.2.1 AAAA Map domain to IPv6 address example.com \u2192 2001:db8::1 CNAME Alias one domain to another www.example.com \u2192 example.com MX Mail exchange servers example.com \u2192 mail.example.com TXT Text information Domain verification, SPF records SRV Service discovery _service._protocol.domain NS Name server records Delegate subdomain to other servers PTR Reverse DNS lookup IP address to domain name"},{"location":"networking/route53/#alias-records-vs-cname","title":"Alias Records vs CNAME","text":"Alias Records Route 53 specific extension   Can be used for root domain (example.com)   Free of charge   Only redirect to AWS resources CNAME Records Standard DNS record   Cannot be used for root domain   Charged per query   Can redirect to any domain <p>Supported Alias Targets - Application Load Balancer - Network Load Balancer - CloudFront distributions - S3 website endpoints - API Gateway - VPC endpoints - Global Accelerator - Other Route 53 records in same hosted zone</p>"},{"location":"networking/route53/#routing-policies","title":"Routing Policies","text":"Simple Routing Single resource for domain   No health checks   Multiple IP addresses return random selection Weighted Routing Distribute traffic based on assigned weights   Useful for A/B testing and gradual deployments   Weight 0 stops traffic to resource Latency-Based Routing Route to region with lowest latency   Requires latency measurements between users and regions   Automatically chooses best performing region Failover Routing Active/passive failover setup   Primary resource serves traffic when healthy   Secondary resource used when primary fails Geolocation Routing Route based on user's geographic location   Country or continent-level routing   Default location for unmatched queries Geoproximity Routing Route based on geographic location with bias   Bias values shift traffic toward/away from resources   Requires Route 53 Traffic Flow Multivalue Answer Routing Return multiple healthy resources   Up to 8 healthy records randomly selected   Simple load balancing with health checks"},{"location":"networking/route53/#health-checks","title":"Health Checks","text":"<p>Types - HTTP/HTTPS: Check web server health - TCP: Check port connectivity - Calculated: Combine multiple health checks - CloudWatch Alarm: Based on CloudWatch metrics</p> Configuration Check interval: 30 seconds (standard) or 10 seconds (fast)   Failure threshold: Number of consecutive failures   Success threshold: Number of consecutive successes   Global health checkers from multiple regions Health Check Locations 15+ global health checking locations   Majority must report healthy for overall healthy status   Can specify minimum number of health checkers"},{"location":"networking/route53/#private-dns","title":"Private DNS","text":"Private Hosted Zones DNS resolution within VPC   Not accessible from internet   Override public DNS for internal resources Requirements enableDnsHostnames and enableDnsSupport must be true   Associate hosted zone with VPC   Can associate with multiple VPCs"},{"location":"networking/route53/#traffic-flow","title":"Traffic Flow","text":"Visual Editor Drag-and-drop interface for complex routing   Version control for traffic policies   Can apply same policy to multiple domains Traffic Policy Reusable configuration for DNS routing   JSON-based policy definition   Supports all routing policies and health checks"},{"location":"networking/route53/#resolver","title":"Resolver","text":"DNS Resolver Route 53 Resolver provides DNS resolution for VPC   Automatically enabled for all VPCs   Resolves AWS service names and custom domains Resolver Endpoints Inbound: External DNS servers query VPC resources   Outbound: VPC resources query external DNS servers   Useful for hybrid cloud DNS resolution"},{"location":"networking/route53/#best-practices","title":"Best Practices","text":"<ul> <li>Use Alias records for AWS resources when possible</li> <li>Implement health checks for critical resources</li> <li>Use appropriate TTL values (lower for dynamic content)</li> <li>Monitor DNS query patterns with Route 53 query logs</li> <li>Use private hosted zones for internal resources</li> <li>Implement DNS failover for high availability</li> <li>Consider latency-based routing for global applications</li> <li>Use weighted routing for gradual deployments</li> </ul>"},{"location":"scaling/auto-scaling-groups/","title":"Definition","text":"<ul> <li>An Auto Scaling group contains a collection of Amazon EC2 instances that span multiple Availability Zones in a region. (not multiple regions)</li> </ul>"},{"location":"security/cognito/","title":"Cognito","text":""},{"location":"security/cognito/#core-concepts","title":"Core Concepts","text":"<p>User management and authentication - Secure user directory and identity broker Two main components - User Pools (authentication) and Identity Pools (authorization) Federated identity - Support for social and enterprise identity providers JWT tokens - Secure token-based authentication</p>"},{"location":"security/cognito/#user-pools-vs-identity-pools","title":"User Pools vs Identity Pools","text":"Feature User Pools Identity Pools Purpose Authentication (Who are you?) Authorization (What can you do?) Function User directory and sign-in AWS service access via IAM roles Output JWT tokens (ID, Access, Refresh) Temporary AWS credentials Users Registered users only Supports anonymous and authenticated Identity Sources Username/password, social, SAML Multiple providers including User Pools"},{"location":"security/cognito/#user-pools-features","title":"User Pools Features","text":"Authentication Methods Username/password with customizable password policies   Social sign-in (Facebook, Google, Amazon, Apple)   SAML and OpenID Connect providers   Multi-factor authentication (SMS, TOTP) Security Features Advanced security with risk-based authentication   Account takeover protection   Compromised credentials detection   Device tracking and management Customization Lambda triggers for custom workflows   Customizable UI for hosted sign-in pages   Custom attributes and verification methods"},{"location":"security/cognito/#identity-pools-features","title":"Identity Pools Features","text":"Identity Sources Cognito User Pools   Social identity providers (Facebook, Google, etc.)   SAML providers   OpenID Connect providers   Developer authenticated identities   Anonymous (guest) users AWS Integration Temporary AWS credentials via STS   Fine-grained IAM policies based on identity   Support for authenticated and unauthenticated roles"},{"location":"security/cognito/#jwt-tokens-user-pools","title":"JWT Tokens (User Pools)","text":"ID Token Contains user identity information   Used for authentication verification   Expires after 1 hour (default) Access Token Used to access User Pool resources   Contains scopes and groups   Expires after 1 hour (default) Refresh Token Used to obtain new ID and Access tokens   Longer expiration (30 days default, up to 10 years)"},{"location":"security/cognito/#common-integration-patterns","title":"Common Integration Patterns","text":"<p>Web/Mobile App Authentication 1. User signs in through User Pool 2. Receive JWT tokens 3. Use tokens to authenticate API calls</p> <p>AWS Service Access 1. User authenticates with User Pool 2. Exchange JWT for AWS credentials via Identity Pool 3. Use credentials to access AWS services (S3, DynamoDB, etc.)</p> <p>Anonymous Access 1. Get temporary credentials from Identity Pool 2. Access limited AWS resources as guest user</p>"},{"location":"security/cognito/#best-practices","title":"Best Practices","text":"<ul> <li>Use User Pools for user management and authentication</li> <li>Use Identity Pools for AWS service access</li> <li>Enable MFA for sensitive applications</li> <li>Implement proper token refresh logic</li> <li>Use least privilege IAM policies for Identity Pool roles</li> <li>Monitor authentication events with CloudWatch</li> </ul>"},{"location":"security/iam/","title":"IAM (Identity and Access Management)","text":""},{"location":"security/iam/#core-components","title":"Core Components","text":"<p>Users: Individual accounts for people or applications Groups: Collections of users with similar permissions Roles: Temporary access for users or services Policies: JSON documents defining permissions</p>"},{"location":"security/iam/#policy-types","title":"Policy Types","text":"<ul> <li>AWS Managed: Pre-built policies by AWS</li> <li>Customer Managed: Custom policies you create</li> <li>Inline: Policies directly attached to users/groups/roles</li> </ul>"},{"location":"security/iam/#policy-evaluation-logic","title":"Policy Evaluation Logic","text":"<ol> <li>Explicit Deny: Always wins</li> <li>Explicit Allow: Required for access</li> <li>Default: Implicit deny if no explicit allow</li> </ol>"},{"location":"security/iam/#authentication-methods","title":"Authentication Methods","text":"<ul> <li>Console Password: Web console access</li> <li>Access Keys: Programmatic access (CLI/SDK)</li> <li>Multi-Factor Authentication (MFA): Additional security layer</li> <li>Temporary Security Credentials: Short-term access</li> </ul>"},{"location":"security/iam/#best-practices","title":"Best Practices","text":"<ul> <li>Least Privilege: Grant minimum permissions needed</li> <li>Use Groups: Assign permissions to groups, not users</li> <li>Regular Audits: Review permissions regularly</li> <li>Strong Passwords: Enforce password policy</li> <li>Enable MFA: Especially for privileged users</li> <li>Rotate Keys: Regular access key rotation</li> </ul>"},{"location":"security/iam/#root-account","title":"Root Account","text":"<p>Use Only For: - Account setup and initial configuration - Creating CloudFront key pairs - Changing account settings - Closing account</p> <p>Secure Root Account: - Enable MFA - Don't use for daily activities - Create IAM admin user instead</p>"},{"location":"security/iam/#special-cases","title":"Special Cases","text":"<p>CloudFront Key Pairs: Only root user can create CodeCommit: Cannot use IAM username/password, use Git credentials or SSH keys Billing Access: IAM users need explicit billing permissions + account-level activation</p>"},{"location":"security/iam/#cross-account-access","title":"Cross-Account Access","text":"<ul> <li>Assume Role: Temporary access across accounts</li> <li>Cross-Account Policies: Resource-based policies</li> <li>External ID: Additional security for role assumption</li> </ul>"},{"location":"security/iam/#service-linked-roles","title":"Service-Linked Roles","text":"<ul> <li>Pre-defined roles for AWS services</li> <li>Created automatically by services</li> <li>Cannot be deleted if service is using them</li> </ul>"},{"location":"security/kms/","title":"AWS KMS (Key Management Service)","text":""},{"location":"security/kms/#what-is-kms","title":"What is KMS?","text":"<ul> <li>Managed service for encryption keys</li> <li>Creates and controls encryption keys used to encrypt data</li> <li>Integrated with most AWS services</li> </ul>"},{"location":"security/kms/#key-types","title":"Key Types","text":""},{"location":"security/kms/#customer-managed-keys-cmk","title":"Customer Managed Keys (CMK)","text":"<ul> <li>You create, own, and manage</li> <li>Can enable/disable, rotate, delete</li> <li>Cost: $1/month per key + usage</li> </ul>"},{"location":"security/kms/#aws-managed-keys","title":"AWS Managed Keys","text":"<ul> <li>Created/managed by AWS services</li> <li>Free to use</li> <li>Automatic rotation every year</li> <li>Cannot delete or manage directly</li> </ul>"},{"location":"security/kms/#aws-owned-keys","title":"AWS Owned Keys","text":"<ul> <li>Used by AWS services internally</li> <li>No additional cost</li> <li>Not visible in your account</li> </ul>"},{"location":"security/kms/#key-operations","title":"Key Operations","text":""},{"location":"security/kms/#encrypt","title":"Encrypt","text":"<ul> <li>Encrypt data up to 4KB directly</li> <li>Returns ciphertext</li> </ul>"},{"location":"security/kms/#decrypt","title":"Decrypt","text":"<ul> <li>Decrypt ciphertext</li> <li>Must have permission to use the key</li> </ul>"},{"location":"security/kms/#generatedatakey","title":"GenerateDataKey","text":"<ul> <li>Creates data encryption key (DEK)</li> <li>Returns plaintext + encrypted version</li> <li>Use plaintext to encrypt, store encrypted version</li> </ul>"},{"location":"security/kms/#generatedatakeywithoutplaintext","title":"GenerateDataKeyWithoutPlaintext","text":"<ul> <li>Returns only encrypted data key</li> <li>Use with Decrypt to get plaintext key</li> </ul>"},{"location":"security/kms/#envelope-encryption","title":"Envelope Encryption","text":"<ul> <li>Encrypt data with Data Encryption Key (DEK)</li> <li>Encrypt DEK with KMS Customer Master Key (CMK)</li> <li>Store encrypted data + encrypted DEK together</li> <li>Decrypt: Use KMS to decrypt DEK, then decrypt data</li> </ul>"},{"location":"security/kms/#key-policies","title":"Key Policies","text":"<ul> <li>JSON-based access control</li> <li>Similar to IAM policies</li> <li>Default policy gives root user full access</li> <li>Can grant cross-account access</li> </ul>"},{"location":"security/kms/#multi-region-keys","title":"Multi-Region Keys","text":"<ul> <li>Same key ID across multiple regions</li> <li>Replicated automatically</li> <li>Each region has independent key material</li> <li>Useful for global applications</li> </ul>"},{"location":"security/kms/#key-rotation","title":"Key Rotation","text":"<ul> <li>Automatic rotation available for CMKs</li> <li>Rotates every year</li> <li>Old key versions remain available for decryption</li> <li>Cannot rotate imported key material</li> </ul>"},{"location":"security/kms/#important-limits","title":"Important Limits","text":"<ul> <li>4KB max data size for direct encryption</li> <li>Regional service</li> <li>API request limits apply</li> <li>Key policies max 32KB</li> </ul>"},{"location":"security/kms/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>EBS volume encryption</li> <li>S3 bucket encryption</li> <li>RDS encryption</li> <li>Lambda environment variables</li> <li>Parameter Store SecureString</li> <li>Secrets Manager</li> </ul>"},{"location":"security/kms/#best-practices","title":"Best Practices","text":"<ul> <li>Use least privilege access</li> <li>Enable key rotation</li> <li>Monitor key usage with CloudTrail</li> <li>Use separate keys for different applications</li> <li>Consider cross-region replication needs</li> </ul>"},{"location":"security/security-manager/","title":"Security Manager","text":"<ul> <li>cross-account access</li> <li>manage IAM policies</li> <li>audit and compliance</li> <li>rotate keys</li> </ul>"},{"location":"security-networking/https/","title":"Enable HTTPS connection","text":"<ul> <li>Deploy SSL/TLS server certificate:</li> <li>ACM: provision, manage and deploy server certificates. In supported Regions, you can request a certificate directly from ACM.</li> <li>IAM: when support HTTPS connection in unsupported ACM Regions. Encrypted private keys and stores in IAM SSL Certificate Store. Supports deploying server certificates in all Regions, but you must otain the certificate from a third-party CA.</li> </ul>"},{"location":"security-networking/security-groups-nacls/","title":"Security Group","text":"<ul> <li>SG is stateful</li> <li>Allowing inbound traffic automatically allows the response outbound traffic</li> <li>By default, SG denies all inbound traffic and allows all outbound traffic</li> <li>Can only allow rules, cannot create deny rules</li> </ul>"},{"location":"security-networking/security-groups-nacls/#network-acls","title":"Network ACLs","text":"<ul> <li>NACL is stateless</li> <li>Must create rules to allow both inbound and outbound traffic</li> <li>By default, NACL allows all inbound and outbound traffic</li> <li>Can create both allow and deny rules</li> <li>Each rule has a number, lower number has higher priority</li> <li>If no rule matches, the default action is to deny</li> </ul>"},{"location":"storage/s3/","title":"S3 (Simple Storage Service)","text":""},{"location":"storage/s3/#overview","title":"Overview","text":"<p>Object storage - Store and retrieve any amount of data Durability: 99.999999999% (11 9's) Availability: 99.95% - 99.99% depending on storage class Globally unique bucket names</p>"},{"location":"storage/s3/#storage-classes","title":"Storage Classes","text":"<ul> <li>Standard: General purpose, frequently accessed</li> <li>Standard-IA: Infrequent access, lower cost</li> <li>One Zone-IA: Single AZ, lower cost than Standard-IA</li> <li>Glacier Instant: Archive with millisecond retrieval</li> <li>Glacier Flexible: Archive with minutes to hours retrieval</li> <li>Glacier Deep Archive: Archive with 12 hours retrieval</li> <li>Intelligent-Tiering: Automatically moves data between tiers</li> </ul>"},{"location":"storage/s3/#encryption","title":"Encryption","text":"Type Key Management Use Case SSE-S3 AWS managed (AES-256) Default encryption SSE-KMS AWS KMS Audit trails, key rotation SSE-C Customer provided Full key control CSE Client-side Encrypt before upload SSE-S3 (Server-Side Encryption) AWS manages keys automatically   Default encryption option SSE-KMS (Key Management Service) AWS managed or customer managed keys   Provides audit trails and key rotation SSE-C (Customer-Provided Keys) You provide keys with each request   AWS doesn't store keys CSE (Client-Side Encryption) Encrypt data before uploading   Full responsibility for key management"},{"location":"storage/s3/#replication","title":"Replication","text":"<p>Same Region Replication (SRR): Within same region Cross-Region Replication (CRR): Across different regions Requirements: Versioning enabled on both buckets Note: Lifecycle policies not replicated</p>"},{"location":"storage/s3/#versioning","title":"Versioning","text":"<ul> <li>Multiple versions of same object</li> <li>Protects against accidental deletion</li> <li>Each version has unique version ID</li> <li>Can suspend but not disable once enabled</li> </ul>"},{"location":"storage/s3/#lifecycle-management","title":"Lifecycle Management","text":"<ul> <li>Transition objects between storage classes</li> <li>Delete objects after specified time</li> <li>Apply to specific prefixes or tags</li> <li>Cost optimization tool</li> </ul>"},{"location":"storage/s3/#access-control","title":"Access Control","text":"<ul> <li>Bucket Policies: JSON-based bucket-level access</li> <li>ACLs: Object and bucket level access (legacy)</li> <li>IAM Policies: User/role-based access</li> <li>Pre-signed URLs: Temporary access to objects</li> </ul>"}]}